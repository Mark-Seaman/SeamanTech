== Appendix C - Component Encapsulation


=== Encapsulation & data hiding
          
The structure of a component determines how versatile it is.  If a component
is more flexible then it will last for a long time.   Rigidity will limit the
lifespan of the software because any change will break it.

We need to be careful not to overbuild the system by making to large of an
investment up front.   Our goal is to do just enough engineering to meet the
need at hand.  But we will stop short of building any functionality or
flexibility that is not needed until later.

There are several areas where we need to apply just enough engineering.  When
building a component we want to only expose what is needed to other parts of
the system.  Everything else should be hidden from the outside world.
Exposing additional data and operations is easily done later.  But the
opposite requires a lot more work.  Hiding data and operations that were
exposed in a troublesome task, which is likely to break code.

The design of a component needs to match the complexity of the task.  It
should be just sophisticated enough to meet the current challenge.  When new
challenges arise as a result of new features, then the current design can be
extended to tackle the new requirements.  Never build a design that you are
not ready to use this afternoon.

Try to envision the simplest possible version of each feature.  Then simplify
it some more.  Do not build complex design rules and logic.  Instead, rethink
the actual requirements, and change them if they produce a more elegant
solution to the problem that you are trying to solve.  Be sure and communicate
with the key stakeholders to help them understand the true cost savings that
can be had by making the requirements less severe.

Every interesting problem in computer science is solved by adding a level of
indirection.  But wait until you have the pressing need before adding the
indirection.  Many engineers are way to quick to put in a general purpose
solution when it is not truly needed.  For example, never build a plug-in
architecture when you only have a couple of things that will use it.  Wait
until you have at least four different consumers of an interface before you
build the mechanism.

If you generalize a solution too early then it will cost a lot more.  Every
solution has design parameters that are impossible to anticipate.  Wait for at
least three instances of a particular design element before you try to
abstract the commonality.  Build flexibility just in time to use it.


=== Extending functionality

There are two competing desires when it comes to extending the code that you
write. We want to complete the work that we produce to eliminate loose ends.
We also want to allow easy changes for later.  It is possible to support both
of these goals simultaneously.

We need clear guidelines about how to extend the functionality after the
initial implementation is complete.   Each part of the system is built
incrementally.  Each piece needs to be completed before the next is started.
If you do not work this way then you end up with a large amount of work in
process.   This quickly becomes an unstable system that will cause the project
to fail.

What does it mean for a small feature to be done?  A clear definition of how
the feature works is created A test verifies that the feature works properly
The code is written to implement the minimum requirements The code has an
optimal structure and style (with no duplication) The code is committed,
tested in the system, and deployed Any open issues that are associated are
resolved

A feature is complete when you never have to think about it again.  This
requires all of the preceding activities to be completed.  If you truly work in
these small steps then a simple feature should be done in fewer than 10 lines of
code and thirty minutes of effort.  You can do a lot of features each day!

When a feature is complete you can think of it as being closed to
modification, but open to extension.  You should not have to revisit the code
for its existing functionality.  But you may to improve the structure or
functionality when using it for a new purpose.

Flexibility in software comes from extending fully implemented and robust
components.  Adding functionality is easy if the design and code is simple and
clean.  Finish your work before moving on, and you will have a firm basis for
what comes next.  If you let problem linger, you will pay a terrible
maintenance cost.

It is impossible to refactor code unless you have unit tests.  A typical
feature is added by adding one line of code.  Then a unit test can be created
by another line of code.  In order to make the structure more readable you
will likely add a function definition to the product and also the test code.
Add a couple of comments to tell someone else what you are doing.

Consciously count the lines of text you type.   Create a set of personal
guidelines and a budget for the code you write.  Constantly strive to write
less code.  100 lines to code a certain function is twice as good as 150
lines, maybe more.  Remember complexity is not linear.


<hr><p><a href="StartReading">Read More</a></p><hr>
