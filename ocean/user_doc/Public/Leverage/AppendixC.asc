== Appendix C - Component Encapsulation


=== Encapsulation & data hiding
          
The structure of a component determines how versatile it is.  If a component
is more flexible then it will last for a long time.   Rigidity will limit the
lifespan of the software because any change will break it.

We need to be careful not to overbuild the system by making to large of an
investment up front.   Our goal is to do just enough engineering to meet the
need at hand.  But we will stop short of building any functionality or
flexibility that is not needed until later.

There are several areas where we need to apply just enough engineering.  When
building a component we want to only expose what is needed to other parts of
the system.  Everything else should be hidden from the outside world.
Exposing additional data and operations is easily done later.  But the
opposite requires a lot more work.  Hiding data and operations that were
exposed in a troublesome task, which is likely to break code.

The design of a component needs to match the complexity of the task.  It
should be just sophisticated enough to meet the current challenge.  When new
challenges arise as a result of new features, then the current design can be
extended to tackle the new requirements.  Never build a design that you are
not ready to use this afternoon.

Try to envision the simplest possible version of each feature.  Then simplify
it some more.  Do not build complex design rules and logic.  Instead, rethink
the actual requirements, and change them if they produce a more elegant
solution to the problem that you are trying to solve.  Be sure and communicate
with the key stakeholders to help them understand the true cost savings that
can be had by making the requirements less severe.

Every interesting problem in computer science is solved by adding a level of
indirection.  But wait until you have the pressing need before adding the
indirection.  Many engineers are way to quick to put in a general purpose
solution when it is not truly needed.  For example, never build a plug-in
architecture when you only have a couple of things that will use it.  Wait
until you have at least four different consumers of an interface before you
build the mechanism.

If you generalize a solution too early then it will cost a lot more.  Every
solution has design parameters that are impossible to anticipate.  Wait for at
least three instances of a particular design element before you try to
abstract the commonality.  Build flexibility just in time to use it.


=== Extending functionality

