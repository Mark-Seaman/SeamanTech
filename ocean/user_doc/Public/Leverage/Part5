* Chapter 4. Strategic testing  *                                       -*-muse-*-

---

Testing that just works
 * Beyond tactics
 * Live data exercises
 * Browser automation
 * Diff testing

---

Many of the books that discuss testing focus on building new systems from scratch.  There are techniques that can be applied from the start of a project that will put the project on stable footing.  If you have the luxury of setting the proper process in place at the beginning then you will save yourself a lot of work later.

Most projects in the real world, however, do not have this luxury.  You will often inherit a mess that someone else has created and have to bring it under control.  Let’s look at testing techniques that are particularly good for dealing with legacy code.

A legacy system is any project that is currently deployed.  It comes with a fully completed product definition, design, and implementation.  It also comes with a history of tradeoffs that were often made by a different team than the one that has inherited it.

Although the system is complete in one sense, it is also quite incomplete.  It has issues associated with every phase of development, including the product definition, design, and implementation.

The first goal of working with a legacy system is to draw a functional and quality baseline.  We must evaluate the issues of each part of the lifecycle to understand how the system works currently.  This will help us determine the priorities of the work that must be done.

Once we have a baseline and priorities, we will need to bring the system under control.  We must build some scaffolding logic and instrumentation around the areas of the code that we intend to work on.  This will protect us from making errors as we begin to extend and improve the system.

Skipping this step in the process is foolish.  Jumping directly into modifying code without a safety net, will cause your software schedule and cost to balloon.

---

**Beyond tactics**

Most testing advice focuses on tactics.  There is quite a lot written on the mechanics of testing.  Our goal is to focus on the strategic nature of testing and how it can be used to reuse software more effectively.  I recommend that you get familiar with tactically testing techniques as well.

What is the role of testing in software leverage?  Testing strategies are most important tool that you have in working with legacy code, yet they are often overlooked.  Engineers often spend too much time thinking about the code changes that are needed, and not enough thinking about how the changes will add risk to the system.

All code work should begin by capturing the exact behavior of the current system.  Implement some test code to record with functional surface area of the app.  Generate a series of requests to your system, and collect the various responses.  Think about hundreds of request/response pairs.  

A single test case is nothing more than a request and its corresponding response.  How these test cases are executed will be a function of your system architecture.  There are numerous way that you could implement these interactions:

 * Function call that return a value
 * Method call on an API
 * HTTP request and response
 * COM or Corba invocation
 * Web service query
 * Database query
 * Key/value pairs
 * Script invocation with a output

Many of the books that discuss testing focus on building new systems from scratch.  There are techniques that can be applied from the start of a project that will put the project on stable footing.  If you have the luxury of setting the proper process in place at the beginning then you will save yourself a lot of work later.

Most projects in the real world, however, do not have this luxury.  You will often inherit a mess that someone else has created and have to bring it under control.  Let’s look at testing techniques that are particularly good for dealing with legacy code.

A legacy system is any project that is currently deployed.  It comes with a fully completed product definition, design, and implementation.  It also comes with a history of tradeoffs that were often made by a different team than the one that has inherited it.

Although the system is complete in one sense, it is also quite incomplete.  It has issues associated with every phase of development, including the product definition, design, and implementation.

The first goal of working with a legacy system is to draw a functional and quality baseline.  We must evaluate the issues of each part of the lifecycle to understand how the system works currently.  This will help us determine the priorities of the work that must be done.

Once we have a baseline and priorities, we will need to bring the system under control.  We must build some scaffolding logic and instrumentation around the areas of the code that we intend to work on.  This will protect us from making errors as we begin to extend and improve the system.

Skipping this step in the process is foolish.  Jumping directly into modifying code without a safety net, will cause your software schedule and cost to balloon.

---

**Beyond tactics**

Most testing advice focuses on tactics.  There is quite a lot written on the mechanics of testing.  Our goal is to focus on the strategic nature of testing and how it can be used to reuse software more effectively.  I recommend that you get familiar with tactically testing techniques as well.

What is the role of testing in software leverage?  Testing strategies are most important tool that you have in working with legacy code, yet they are often overlooked.  Engineers often spend too much time thinking about the code changes that are needed, and not enough thinking about how the changes will add risk to the system.

All code work should begin by capturing the exact behavior of the current system.  Implement some test code to record with functional surface area of the app.  Generate a series of requests to your system, and collect the various responses.  Think about hundreds of request/response pairs.  

A single test case is nothing more than a request and its corresponding response.  How these test cases are executed will be a function of your system architecture.  There are numerous way that you could implement these interactions:

 * Method call on an API
 * HTTP request and response
 * COM or Corba invocation
 * Web service query
 * Database query
 * Key/value pairs
 * Script invocation with a output

Decide on what makes sense for your system.  Do the thing that is easiest and most natural for you.   But do something.   You will rest a lot easier if you know that you have a library of hundreds of test cases that you can run in a few seconds.

Build simple test cases, rather than complex ones.  Don’t build test cases with multiple clauses that are trying to check for multiple things at once.  Instead, build many different test cases.  Set these up as tables.  Have a tool that will execute everything at once.  Run all of your tests at least once every hour.  Run extended test at least daily to ensure that you didn’t miss anything.

Think about the types of testing that you need to give you boss 100% confidence guarantee that everything is working as it should be.  Budget your testing effort to focus on the most critical areas.  Give special priority to:

 * Areas that need a lot of new functionality
 * Performance bottlenecks
 * Parts with a lot of issues historically
 * Sources of current defects and other issues
 * Costly parts requiring extra development time
 * Areas of disagreements within the team
 * Modules with many changes or multiple authors

Consider creating a test plan that has a table of all modules and your key attributes for making decisions about the priority of each.  Create a scoring scheme that matches the business and development objectives of your organization.  Score every module and use to results to set the development priorities.

Select tools and techniques for each module that will be used to encode and execute the test cases.  Now determine how many test cases you need to make you feel comfortable with the control that you have over that module.

Testing becomes strategic when it drives the rest of the development.  Strategic testing is automated and involves executing stacks of test cases without any intervention (other than pulling the trigger).  A table of results tells you which tests fail so that all failures can be fixed in seconds not hours.  Testing is planned globally, but focused on local hotspots in the code.

When strategic testing is applied to a project the code gets healthier over time.  This is primarily caused by the ability to constantly refactor the code.  Refactoring cannot be done safely without tests. There is too much risk that something will break and you won’t discover it for months.

Testing is the code that we add to the product to notify us of a false assumption.  When we write the test we verify what we know to be true.  Six month later, that assumption is no longer valid and our test informs us of the failure.

Testing turns back the effects of bit rot.  All software system will naturally decay due to changes in the work around and within the system.  Testing is the early warning system that tells you something is wrong long before the angry phone call from the VP.

---

**Live data exercises**

Most systems deal with some type of data.  These objects may to Orders, Students, Launch codes, Sensor readings.  No matter what the data types represent, there are certain to be some core operations that you will need to do.  CRUD (create, read, update, delete) is one set of operations that you will probably need.  Your application may also call for other operations (eg. execute, recover, rollback, commit).

Build a command language to capture these types of operations on your data.  Implement CRUD as a starting point but extend your language to cover the specialized verbs that you need most.  This language is your injection point for trying out your test cases.

Use your DSL (domain-specific language) for making requests of your system.  Remember that a test case is just a request/response pair.  You DSL should allow you to implement a single test case on a single line of code.

At this point you are building a conversation with your system.   It is important to design safety switches, that prevent altering the system behavior within your production environment.  This can follow two main patterns: sentinels and fake data.  The sentinel pattern involves preventing certain operations from occurring on certain systems.  For example, don’t send notification emails from the staging server, or allow actual orders to be sent only from the production server.

The fake data pattern marks all of the fake data inserted into the system.  This lets real data and fake data to mingle within a system without being configused.  Certain commands can be prohibited on the fake data (or the real data).  For example, "never send email to a fake user", or "do not delete real users” would fall into this camp.

Once you have a command language that interacts with your objects, you can start telling stories.  These stories could be composed of transactions that alter the state of the system.  For example:

 * add character Evil Queen
 * add character Cinderella
 * build Castle
 * move Evil Queen to Castle
 * show Castle
 * list characters

Executing transactions advances the state of our stories.  Other transactions can reveal the current state.  Imagine the possibilities for build testing scenarios.  The individual test cases each combine a request with a response, but they also change the state of the system.  Some of the test cases just verify that the system got to the correct state at the right time.

Test fixtures allow the system to be advance instantly to a known state.  Fixtures are often encoded as JSON data and loaded into the system.   Instead of replaying the transactions in a story, you can jump to the end result.  This lets you set the starting state on the system, add some new transactions, and then check the ending state.

In the above example, “save game MyGame” and “load game MyGame” could allow us to save the entire game and recall it from a file.  Now entire scenarios can be tested with live data on the live system.  Keep in mind that in a real system you need to build in safeguards to prevent distraction of actual data.

The best safeguard you can put in place is to have a robust server strategy.  I recommend having at least three tiers of servers.

Production - Enable passive monitoring and notifications of errors, but never allow live data testing
Staging - Identical to production, except for the fundamental connections to customers
Dev - All servers used to develop and test the software

Make sure that everyone in your organization understands and follows the guidelines for the server.  I recommend that you put automation in place to enforce the correct behavior rather than relying on discipline of the individuals.

---

**Browser automation**

Selenium is a tool that acts as a remote controller for a web browser.  It works on top of all of the popular browsers.  You can get it to fetch certain pages from the web server and find certain elements in the DOM.  You can even script activities like logging in and entering text in a search box.

Web development is an important part of most software these days.  Selenium is the best tool for testing web servers by using a browser.  There are also other tools like wget and curl that give you command line scripting of page interactions.  No matter what tools you use you should build practices that work for you to do effective testing of the full system.

While most testing requires running on the servers where the software is installed, this type of testing almost always runs on development machines that are not on the productions servers.  Full blown page testing often starts as a simple page tester that gets a page from the production server periodically.  This simple test can serve as a monitor that the production server is up and running.

Once the infrastructure is in place it is easy to keep expanding this testing.   Scripts can contain logic to detect a wide range of errors that might occur in your application.  Your only limitation is the imagination that you have and the time you are willing to invest in contriving test scenarios.

Pages can be fetched from the server. Then you can easily compare either the text or the HTML of the page that you got with the expected answer.  An automated tool like this can easily fetch 100 pages and find the three pages that have errors on them.  You may choose to fix the product or just approve the answer that you just got as the new right answer.

Selenium can be used for animating the Java Script controls for the front end of an application.  Many apps are becoming increasingly complex on the front end.  Selenium may give you the tools that you need to test out all of the interactions of controls that contain a lot of Java Script functionality.  If you are going to do a lot of this type of work you might want to investigate tools that specialize in this area.

User stories define the specific scenarios that users are trying to accomplish when they use your system.  Consider using Selenium as the basis of a test app that will walk through each of the scenarios.  The app can fetch page, login, click on certain controls, and view tables and other page content.

Example Test Scenario:

 * Go to home page
 * Login as “Bill Gates"
 * View product selections
 * Click on order product
 * Fill out shipping form
 * Submit order
 * View “Thank You” page

---

**Diff testing**

The most important goal of a test system is that it is easy to create new tests, run all tests, and fix failing tests.   If these tasks are difficult then testing will be abandoned.  Trying to test a product and not succeeding, is far worse then never trying at all. 

I’ve been practicing unit testing for 25 years.  The most common reaction I get when trying to get an organization to use the techniques, “Oh, we tried testing once and it didn’t work for us”.  As a result these organization have abandoned testing altogether in favor of lots of people using the product and logging defects.  Another recurring cop-out is to say, “All our developers do their own testing”.

The reason that most attempt at automatic testing fail, is that it is too hard to maintain the test.  If it were easy to create, run, and approve tests, everyone would do it.  The techniques proposed here will let you do just that.

In 15 seconds you should be able to ...
 * execute all tests
 * create a new test
 * approve the answer you just got for a test
 * modify the test case

You should be able to quickly perform any of the core actions within 15 seconds.  In an hour you should be able to generate close to 100 tests for a system that you already know quite well.  This is perfect for when you are trying to implement numerous tests for a legacy system.  A competent engineer should be able to wrap and entire system in tests in about a day.

Now, let’s look at how all this works.  Tests are just shell scripts that produce output.  We could get fancier than that but we won’t for now.  When a test is executed we capture the output including any errors that were produced.

We compare the output of the test with what we were expecting.  The differences between the actual and expected results are shown.  These are calculated by using a ‘diff’ script.  If the actual results match expected results, then diff generates no output.  That is a passing test.

The tester may approve the actual results that were returned from executing the test.  This makes the current output the right answer for next time.  If the test is run then the test passes.

There are several simple commands to manage test state.

 * **trun** - run a specific test and capture its output
 * **tlike** - approve of this output, expect it next time
 * **tnew** - make a new test script
 * **tedit** - edit the source code for the script

A lot of functionality can be added to these commands to solve other problems, but this is a perfectly useful starting point for your testing activities.  For more discussion on a fully built-out test system use Google to search for “Mark Seaman Jack Hammer”.

---

Testing is your most strategic tool to increase your leverage!
