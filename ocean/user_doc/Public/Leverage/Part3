* Chapter 2. Design Phase *                                       -*-muse-*-

---

Creating a reusable architecture

 * Strategic Interfaces
 * Refactored frameworks
 * Design patterns/idioms
 * Evolutionary design

---

**Creating a reusable architecture**

The quality of the software architecture directly depends on the strength of the interfaces.  Design is all about the interfaces between the components.  A reusable architecture has well encapsulated components and standard interactions between those components.

A poor architecture has very weak components and lots of complex and custom interactions between them.  A weak architecture does not even meet the needs of its initial use, and breaks entirely when you try to extend the business needs to a second generation solution.

The best architectures emerge from successfully refactoring the common functionality out of several different applications.  Each application is created as if it is the only one.  Two applications within the same domain will share a lot of common design elements.

A skilled software architect we discover and identify these common elements.  Then they can be extracted into a framework that contains the general logic without any of the specific details from the original implementations.

Once the refactored framework is stable, the original applications are converted to use the new framework.  This is a fairly mechanical process, since the design elements originated from the specific applications themselves.

Now the framework can be used in a third implementation.  This code will never contain the application-specific logic that the first two implementations had.  It utilizes the generalized logic right from the start.

Inevitably, the third implementation will also require extensions to the general framework.  All three applications (and the ones following) will influence the framework by adding additional features.  Each new implementation will continue to influence the design, but to a diminishing extent.  Eventually, the design of the framework will stabilize.

The end result of this approach is a generalized architecture that is minimal, robust, clean, and well-factored.  It can live for many years and service tens or hundreds of projects for decades.

This is a high-level description of what happens in an evolutionary design.  A rigid design is built at one time, but a flexible design is more organic.  A design built in a day will last for two years, while a design that can evolve over years will live forever.

For maximum leverage, you are looking for a design than can morph into something that goes far beyond the original intent.

---

**Strategic Interfaces**

An interface is the connection between two parts of the system.  Interfaces and components are the primary design elements.  Multiple subsystems (or components) are connected to each other by interfaces.

A well designed component is well connected on the inside and loosely connected to other components.  In fact, it is so loosely connected, that we can draw an arrow between two-components and describe the exact range of interactions that are possible.

Every interface should be tested.  Collectively the interfaces represent the primary interactions throughout the design.  We should test all of the assumptions that occur on each interface.  

For example, assume we have an employee model with a name an ID.  The interface to employee should contain things like get the name and id, add an employee, update this employee, and delete this one.  These operations are an encapsulation of the idea of employee in our system.

Each operation should have test cases that make sure that our employee does what it is supposed to do.  Test the employee interface by making employee do everything it is designed to do.

Each interface represents some kind of story.  Embody the possible operations as test cases or story elements.

Examples:
 * An employee is added
 * The name and ID are retrieved
 * The employee is updated
 * An employee is deleted
 * A list of all employees is created

Write one or more test cases for every story.  You may also choose to create a language that allows you to create your own scenarios.  This is a really easy way to automate an interface.  You can verify key things about the interactions.

---

**Refactored frameworks**

Many engineers try to create a generalized solution for problems they need to solve.  The reasoning is that they know eventually that certain other problems must be handled.  They believe that it will cost extra work to do it later.

This is almost always a mistake.  It assumes that you know enough about the future problem to anticipate which direction the overall design will take.  It is also harder to solve multiple problems at the same time.

The quickest way to build any application is one line at a time.  One line of test code; one line of product code. Then pause to remove any duplication that you see.  This process of baby steps will let you move extremely quickly.

Refactoring is the most important design skill that you have.  It lets you continue the design work throughout the project rather than move the design to the start of the project.

Every engineer should understand the content of Martin Fowler’s book, “Software Reuse”.  Refactoring is a survival skill that every engineer must master.  It prevents bit rot and protects your software investment.

It is important, at the function level, to make sure that a small chunk of code is improving over time.  Functions that are similar to one another should be combined while the overall complexity is reduced.  Well written code should read like a story.

Refactoring also applies at the larger level within the software.  Design patterns are applied to remove duplication.  When you are reading through code and get a sense of deja vu, then it is time to refactor.

The first time you solve a problem, create a custom solution from scratch.  Then pause to think about what elements remind you of things you have written before.  Then refactor until you have removed the redundancy.

The second time, solve similar problem creating a second custom solution. Then pause to think about what elements remind you of things you have written before.  Then refactor until you have removed the redundancy.

Junior engineers generalize to early.  They anticipate the problems that must be solved later.  More experienced engineers get the design working quickly in the simplest possible way.  Then the refactoring is a mechanical operation that is applied to get the structure right.  Make it work, make it beautiful, make it simple.

The result of this process is to produce general purpose solutions for hundreds of individual problems.  A well-factored framework provides standard solutions to common problems.  

---

**Design patterns/idioms**

The goal of design patterns is to have a standard way to solve common problems.  When you encounter a situation that looks like THIS, the best way to handle it is THAT.

Our goal is to build a catalog of these design patterns that work for the situations that we are most likely to encounter.  A framework is an application that embodies many design patterns.  Understanding the principles behind design patterns gives us the ability to build stronger frameworks.

Every organization should build its own catalog of design patterns, as well as style guidelines, and programming idioms.  This should become part of the culture of every software organization.  Why should every engineer have to struggle through the design of a problem that has already been solved by someone else?

Each organization needs to have a culture of learning and growing.  Collaboration between engineers is important for both productivity and reusability.  If every engineer solves the same problem in different ways then the design become increasingly brittle with each contribution.

Organizations that produce the worst software have engineers that operate totally independent from one another.  There must be a culture of sharing in order to reuse software.  If you cannot create this culture, then you must resign your efforts to rewriting your software from scratch every year or two.

A healthy software organization will have the right balance between autonomy of the individuals, and good leadership.  A technical leader must oversee the architecture.  They work on reviewing the patterns, architecture, and performance of the overall system.  They help to train team members when needed and ensure a happy outcome.

---
        
**Evolutionary design**

Rigid architectures do not change.  The initial needs of the design can be easily met.  But when you start trying to solve a slightly different problem it takes an unreasonable amount of effort to make the changes.

If the design is healthy, then a small change is easy and a big change is possible.   With a bad architecture, then a small change is hard, and a big change is impossible.  Any change that can be described in six words, should be implemented in one line of code.

It should never take 100 lines of code to "add one employee record” or “calculate order total”.  If the implementation is not easy then the design is not right.

Healthy architectures change daily.   A bad design lasts forever, creating great sorrow throughout the project.

Designs solve a problem.  If the problem changes, then the design must be changed to match the new needs. A design cannot be static, unless the problem never changes.  In this case, you should probably stop working on the project since all interesting problems have already been solved.

We all want flexible designs, but flexibility comes from flexing.  The design will only honor those constraints that you have forced it to accommodate. If you need a function to take either integers or floating point number then you have to design and test those capabilities in.

Never assume something works until you have an automatic test that verifies it.  Trust, but verify… without the trust.  Testing is the way that you flex a software system.

If you are building a framework or toolkit that is expected to be used in an environment quite different from the design environment, then you must test the full range of operations that might be done by all of your users.

Refactoring is a strategic tool that allows you to incrementally improve your design to match the changing business conditions.  No matter how brilliant your designer are, they cannot see into the future.   Therefore, refactoring is necessary to protect your software investment.  

If you cannot evolve a design over time, then it will suffer bit rot.  Designs must change, especially when reusing software.  The very idea of reuse is to find a new purpose for a piece of software that is somewhat unique from the original.


