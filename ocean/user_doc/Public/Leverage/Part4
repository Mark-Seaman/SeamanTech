* Chapter 3.  Code Phase *                                       -*-muse-*-

---

Building reusable components

 * Encapsulation & data hiding
 * Extending functionality
 * Testing scenarios
 * Automation interfaces

---

**Building reusable components**

Creating reusable code is not hard.  There are a few simple principles that govern how flexible the code is.  Then it takes constant discipline to prevent shortcuts that will limit reuse later.

Code that is well encapsulated can be used in environments that differ drastically from the original context.  Code that is not connected to all of its surroundings will not break when the context changes.  This is the most important principle for code reuse.

The next principle that helps us reuse code is to have a clear way to extend the functionality beyond its first usage.  You must be able to flex the code in a new direction that does not risk breaking everything that was working.  We will look at some techniques for building flexibility into the original design, without paying a big price during the first implementation.

Code that cannot be tested easily will never be flexible.  Automatic tests are a necessity for all but the smallest of software systems.  You must be able to make a small change and guarantee that everything else is still working properly.  Refactoring cannot be done economically without automated testing.

Every system has a few key interfaces that do most of the work.  Why not consider building a language to interact with the key elements of your API?  This lets you build scenarios to create data in your system, capture key traffic across the interface, and playback transactions from earlier recordings. We will look at how to use these remote control capabilities to extend the reuse of your software.

---

**Encapsulation & data hiding**
          
The structure of a component determines how versatile it is.  If a component is more flexible then it will last for a long time.   Rigidity will limit the lifespan of the software because any change will break it.

We need to be careful not to overbuild the system by making to large of an investment up front.   Our goal is to do just enough engineering to meet the need at hand.  But we will stop short of building any functionality or flexibility that is not needed until later.  

There are several areas where we need to apply just enough engineering.  When building a component we want to only expose what is needed to other parts of the system.  Everything else should be hidden from the outside world.  Exposing additional data and operations is easily done later.  But the opposite requires a lot more work.  Hiding data and operations that were exposed in a troublesome task, which is likely to break code.

The design of a component needs to match the complexity of the task.  It should be just sophisticated enough to meet the current challenge.  When new challenges arise as a result of new features, then the current design can be extended to tackle the new requirements.  Never build a design that you are not ready to use this afternoon.

Try to envision the simplest possible version of each feature.  Then simplify it some more.  Don’t build complex design rules and logic.  Instead, rethink the actual requirements, and change them if they produce a more elegant solution to the problem that you are trying to solve.  Be sure and communicate with the key stakeholders to help them understand the true cost savings that can be had by making the requirements less severe.

Every interesting problem in computer science is solved by adding a level of indirection.  But wait until you have the pressing need before adding the indirection.  Many engineers are way to quick to put in a general purpose solution when it is not truly needed.  For example, never build a plug-in architecture when you only have a couple of things that will use it.  Wait until you have at least four different consumers of an interface before you build the mechanism.

If you generalize a solution too early then it will cost a lot more.  Every solution has design parameters that are impossible to anticipate.  Wait for at least three instances of a particular design element before you try to abstract the commonality.  Build flexibility just in time to use it.

---

**Extending functionality**

There are two competing desires when it comes to extending the code that you write. We want to complete the work that we produce to eliminate loose ends.  We also want to allow easy changes for later.  It is possible to support both of these goals simultaneously.

We need clear guidelines about how to extend the functionality after the initial implementation is complete.   Each part of the system is built incrementally.  Each piece needs to be completed before the next is started.  If you do not work this way then you end up with a large amount of work in process.   This quickly becomes an unstable system that will cause the project to fail.

What does it mean for a small feature to be done? 
A clear definition of how the feature works is created
A test verifies that the feature works properly
The code is written to implement the minimum requirements
The code has an optimal structure and style (with no duplication)
The code is committed, tested in the system, and deployed
Any open issues that are associated are resolved

A feature is complete when you never have to think about it again.  This requires all of the preceding activities to be completed.  If you truly work in these small steps then a simple feature should be done in fewer than 10 lines of code and 30 mins of effort.  You can do a lot of features each day!

When a feature is complete you can think of it as being closed to modification, but open to extension.  You should not have to revisit the code for its existing functionality.  But you may to improve the structure or functionality when using it for a new purpose.

Flexibility in software comes from extending fully implemented and robust components.  Adding functionality is easy if the design and code is simple and clean.  Finish your work before moving on, and you will have a firm basis for what comes next.  If you let problem linger, you will pay a terrible maintenance cost.

It is impossible to refactor code unless you have unit tests.  A typical feature is added by adding one line of code.  Then a unit test can be created by another line of code.  In order to make the structure more readable you will likely add a function definition to the product and also the test code.  Add a couple of comments to tell someone else what you are doing.

Consciously count the lines of text you type.   Create a set of personal guidelines and a budget for the code you write.  Constantly strive to write less code.  100 lines to code a certain function is twice as good as 150 lines, maybe more.  Remember complexity is not linear.

---

**Testing scenarios**

Each feature in your product should have a test case.  Each line of code should represent some requirement in your software.  A test case can be implemented in a single line of code.  This give us the following guideline.

     Lines of product code = Line of test code

In other words, if you count the source code in your project you should have about 50% test code.  This seems like an unreasonable and radical requirement for those who do not test there code.  But this practice is well supported by many studies throughout the industry.

Do not code complex test.  Instead, focus on simple assertions that can be easily written as a single line.  Pick isolated things that you require to be true.  Hardcode everything and pick as many test cases as you need.  Set time goals for writing tests.  This forces you to do it, but keeps it simple.  My personal goal is write a test in 30 seconds.

Anything that is a function should be called from a test case.  Why would you wish to have code in your product that is not tested?  For more interesting functions you need to have multiple test cases.  But even a single invocation will detect a lot of catastrophic failures.

I have been doing unit testing for twenty years.  I find that the simpler tests are better.  They break less, and require less effort to fix.  I have seen countless team abandon unit testing simply because they would only pursue a glorious version that tested every possible path.

This is a serious mistake that could undermine your projects success.  My advice is simple.  Build a simple test case for every line that needs to work.   The lines that you don’t care about should be removed from the source code.

Software is build by compositing low level features into medium sized ones, and finally into top-level programs.  When tests are written with the product code they should start at the lowest level feature.  As you turn on a small scale feature you code a test to verify what you intend.

This causes the development to go from the inside (lowest level) to the outside (application level) of the software.  A system built in this way will generate thousands of test cases that are a byproduct of the development itself.   You try a simple thing and save the code for later execution.

The entire battery of thousands of test cases will ensure that the last change you made did not cause any new problems.  Every hour you can run your tests.  Whenever anyone commits code you can run your tests. 

This kind of testing is essential to refactoring.  If you do not develop unit test, then you will never have the confidence to refactor your code.  If you cannot regularly refactor, then your software will decay into disuse within two years.  Your choice!

---

**Automation interfaces**

Every subsystem in a piece of software does something interesting.  Each component serves a purpose.  The strongest abstractions in the system are verb/noun pairs.  

The nouns in the system are the types of data objects that are being saved, recalled, and acted upon.  They are typically represented as models in the program and persisted as database rows.

The verbs in the system represent the operations that are performed.  They are typically implemented as functions or method calls on objects.

All of the business logic in an application comes down to these interactions between nouns and verbs.  Examples would include:
 * list customer
 * add order
 * build inventory
 * import doomsday_device
 * launch missiles 
 * signal surrender

Most applications are built around one to four key interfaces.  These are the logic points of interaction with your application.  An automation interface allows you do have an important conversation at that point with your application.

Consider the last app you worked on.  What was the most important interface in that app?  Now identify the nouns and verbs you worked with.  Wouldn’t it be cool to have a language that would let you converse with your app right there?

Imagine being able to capture the traffic at that spot and save it to a log file.  You could have a transaction log that gives you a quick playback of the history as it existed at another point in time.  Capture and playback gives you amazing control over running specific scenarios within your system.  You can also capture sequences and move them to a different system.

An automation interface gives you a wide range of options.  Systems that have explicit automation interfaces exposed are far more flexible than other system that cannot be controlled from the outside. 

Exposing an interface and implementing a text language to drive it is extremely simple.   I recommend that everyone consider building at least one key interface to their application.  It will come in useful in ways that you cannot even anticipate.   It is not necessary to predict all the ways that you will make use of the interface.

A domain specific language (or DSL) is a term that makes all this sound sophisticated.  But the practice of automated interfaces is really just common sense.  These command interpreters can be built in any language in a day by a competent programmer.

