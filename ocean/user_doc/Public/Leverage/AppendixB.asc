== Appendix B - Testing Automation Interfaces


=== Build around testing scenarios

Each feature in your product should have a test case.  Each line of code
should represent some requirement in your software.  A test case can be
implemented in a single line of code.  This give us the following guideline.

     Lines of product code = Line of test code

In other words, if you count the source code in your project you should have
about 50% test code.  This seems like an unreasonable and radical requirement
for those who do not test there code.  But this practice is well supported by
many studies throughout the industry.

Do not code complex test.  Instead, focus on simple assertions that can be
easily written as a single line.  Pick isolated things that you require to be
true.  Hard-code everything and pick as many test cases as you need.  Set time
goals for writing tests.  This forces you to do it, but keeps it simple.  My
personal goal is write a test in 30 seconds.

Anything that is a function should be called from a test case.  Why would you
wish to have code in your product that is not tested?  For more interesting
functions you need to have multiple test cases.  But even a single invocation
will detect a lot of catastrophic failures.

I have been doing unit testing for twenty years.  I find that the simpler
tests are better.  They break less, and require less effort to fix.  I have
seen countless team abandon unit testing simply because they would only pursue
a glorious version that tested every possible path.

This is a serious mistake that could undermine your projects success.  My
advice is simple.  Build a simple test case for every line that needs to work.
The lines that you do not care about should be removed from the source code.

Software is build by compositing low level features into medium sized ones,
and finally into top-level programs.  When tests are written with the product
code they should start at the lowest level feature.  As you turn on a small
scale feature you code a test to verify what you intend.

This causes the development to go from the inside (lowest level) to the
outside (application level) of the software.  A system built in this way will
generate thousands of test cases that are a byproduct of the development
itself.   You try a simple thing and save the code for later execution.

The entire battery of thousands of test cases will ensure that the last change
you made did not cause any new problems.  Every hour you can run your tests.
Whenever anyone commits code you can run your tests.

This kind of testing is essential to refactoring.  If you do not develop unit
test, then you will never have the confidence to refactor your code.  If you
cannot regularly refactor, then your software will decay into disuse within
two years.  Your choice!


=== Stimulate the interface

Every subsystem in a piece of software does something interesting.  Each
component serves a purpose.  The strongest abstractions in the system are
verb/noun pairs.

The nouns in the system are the types of data objects that are being saved,
recalled, and acted upon.  They are typically represented as models in the
program and persisted as database rows.

The verbs in the system represent the operations that are performed.  They are
typically implemented as functions or method calls on objects.

All of the business logic in an application comes down to these interactions
between nouns and verbs.  Examples would include:

* list customer add order build inventory import doomsday_device launch
* missiles  signal surrender

Most applications are built around one to four key interfaces.  These are the
logic points of interaction with your application.  An automation interface
allows you do have an important conversation at that point with your
application.

Consider the last app you worked on.  What was the most important interface in
that app?  Now identify the nouns and verbs you worked with.  Would not it be
cool to have a language that would let you converse with your app right there?

Imagine being able to capture the traffic at that spot and save it to a log
file.  You could have a transaction log that gives you a quick playback of the
history as it existed at another point in time.  Capture and playback gives
you amazing control over running specific scenarios within your system.  You
can also capture sequences and move them to a different system.

An automation interface gives you a wide range of options.  Systems that have
explicit automation interfaces exposed are far more flexible than other system
that cannot be controlled from the outside.

Exposing an interface and implementing a text language to drive it is
extremely simple.   I recommend that everyone consider building at least one
key interface to their application.  It will come in useful in ways that you
cannot even anticipate.   It is not necessary to predict all the ways that you
will make use of the interface.

<hr><p><a href="StartReading">Read More</a></p><hr>
