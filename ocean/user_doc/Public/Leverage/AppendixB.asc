== Appendix B - Testing Automation Interfaces


=== Build around testing scenarios

Each feature in your product should have a test case.  Each line of code
should represent some requirement in your software.  A test case can be
implemented in a single line of code.  This give us the following guideline.

     Lines of product code = Line of test code

In other words, if you count the source code in your project you should have
about 50% test code.  This seems like an unreasonable and radical requirement
for those who do not test there code.  But this practice is well supported by
many studies throughout the industry.

Do not code complex test.  Instead, focus on simple assertions that can be
easily written as a single line.  Pick isolated things that you require to be
true.  Hard-code everything and pick as many test cases as you need.  Set time
goals for writing tests.  This forces you to do it, but keeps it simple.  My
personal goal is write a test in 30 seconds.

Anything that is a function should be called from a test case.  Why would you
wish to have code in your product that is not tested?  For more interesting
functions you need to have multiple test cases.  But even a single invocation
will detect a lot of catastrophic failures.

I have been doing unit testing for twenty years.  I find that the simpler
tests are better.  They break less, and require less effort to fix.  I have
seen countless team abandon unit testing simply because they would only pursue
a glorious version that tested every possible path.

This is a serious mistake that could undermine your projects success.  My
advice is simple.  Build a simple test case for every line that needs to work.
The lines that you do not care about should be removed from the source code.

Software is build by compositing low level features into medium sized ones,
and finally into top-level programs.  When tests are written with the product
code they should start at the lowest level feature.  As you turn on a small
scale feature you code a test to verify what you intend.

This causes the development to go from the inside (lowest level) to the
outside (application level) of the software.  A system built in this way will
generate thousands of test cases that are a byproduct of the development
itself.   You try a simple thing and save the code for later execution.

The entire battery of thousands of test cases will ensure that the last change
you made did not cause any new problems.  Every hour you can run your tests.
Whenever anyone commits code you can run your tests.

