** Appendix A - Build Your Own Complexity Measurement Tool

*** Enumerate source code

A system is built from source code.  This is any code that a human must write
and maintain.  A tool might be written in 100 lines of code to emit an XML file
of one million lines or it could be an algorithm written in 100 lines of C#.
Both of these examples only count for 100 lines of source code, since the million
lines is automatically generated and therefore not source code.

Almost all of the source code can be organized as files with lines of text.
Letâ€™s count the files in our project, the lines in each file, and the total
lines of source in our project.

Complexity should be measured to reflect the mental burden associated with the
maintenance of the code.  The first dynamic that causes complexity is the sheer
size of the source code. A project of 100,000 lines is more than twice as 
complex as a project of 50,000.  Complexity grows exponentially with size.

For a really cheap measurement create the following shell script to count
C++ code.
    
    find . -name *.cpp - *.h | wc -l

This script alone will give you an overview of your source code.  It is certain
to reveal hot spots that should be addressed.  It is based on one key assumption
that files contain logic and a very long file is an indicator of complexity.
This may be all the sophistication you need.  If so use it and go no further.

If you are still not satisfied, move on to build a tool that is based on a 
deeper understanding of code complexity.  The first task is to find all of our
source code.  We will build a tool that lists all the python files in the 
directory and reads the text from each file and removes blank lines.


    def python_source_code():
        return glob(d+'/*.py')


    def read_source(filename):
        text = open(filename).readlines()
        lines = [x for x in text if x.replace(' ','')]
        return lines


    def list_code():
        for f in python_source_code():
            for line in read_source(f):
                print(line)

    list_code()


*** Measure module size

You can easily adapt this code to your environment and language choices.  
Building your own tool is far better than using a pre-built tool. You want to
reflect your own specialized and dynamic needs in your tool.  The next step in
building a complexity tool is to measure the size of each of the files in the
source code.

    def module_size():
       for f in python_source_code():
            source = read_source(f)
            print(f + ' lines:' + source)


*** Calculate complexity

Now we account for the exponential impact of size on complexity. The print
function is converted to a complexity term.  A exponent of 1.2 is used to 
account for the interactions of each line with the other lines in the file.
This is a parameter that you will tune to reflect your situation.  The value 
could be set from 1.0 (reflecting not internal interaction) all the way to
2.0 (reflecting that every line affects every other line).   1.2 is a good
start until you have evidence to the contrary.


   def module_complexity():
       for f in python_source_code():
            source = read_source(f)
            complexity = len(source) ** 1.2
            print(f + ' complexity:' + complexity)


The next development is to look at the functions within the module.  We will 
identify the length of each function within the source code. The is_function
code locates the functions within the source and the list_functions logic
calculates the lines within the function.

    def is_function(line):
        if line.strip().startswith('def'):
            pat = compile(r"\s*def (.*)\s*\(.*")
            name = pat.sub(r'\1',line)
            return name


    def list_functions(lines):
        start = 0
        for i,line in enumerate(lines):
