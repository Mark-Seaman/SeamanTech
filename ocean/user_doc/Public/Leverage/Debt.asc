== Technical Debt




[quote, ~ Bill Hewlett]
____
"We wished to operate, as much as possible, on a pay-as-you-go basis, 
that our growth be financed by our earnings and not by debt."
____



=== Understanding Technical Debt

Technical debt is a lot like like financial debt. Tech giants Bill Hewlett and
David Packard decided on a very controversial path by rejecting using debt to
grow their business. This counter-cultural stance contributed significantly to
the financial stability and success of HP. As architects, we must also make a
similar stand to protect our systems from the Siren's call of easy results at
the expense of technical debt and the resulting rapid decay.

Before we can figure out how to decrease the technical debt on a project we have
to find it. Martin Fowler's classic book, "Refactoring: Improving the Design of
Existing Code", provided us with excellent advice on how to keep our code clean.

His analogy is when cleaning house we use our nose to detect bad smells that
need to be addressed. We can learn to detect bad things within our code by
learning to identify the bad smells. This is certainly true of old code but it
can also be generalized to the broader scope of project debt. Some projects may
have very little code debt and massive planning debt. Learning to recognize the
full range of bad smells that emanate from a project is a valuable skill.


==== Problem Solving Dynamics

Debt starts with a problem. Engineers can often solve a single problem in an
hour. This means that an engineer can solve roughly 2,000 problems every year.
But what if the project calls for you to solve 4000 problems every year?

Problems happen in every domain and they all compete for a limited bank of mindshare:

* Definition of the product
* Implementation of new features
* Writing tests
* Supervising the test execution
* Sending out early marketing units
* Attending mandatory corporate training sessions
* Writing TPS reports
* Reporting scrum status
* Preparing for the visit of the VP
* Addressing customer issues for the existing project
* Investigating a new tool for continuous delivery
* Making sure that everyone is able to use the new Integrated Development Environment

This list is infinite but each engineer only has one brain. Which 2000 problems
will you solve over the next year? You will choose wisely by selecting the
problems that bring you the biggest return on investment. Do the easy stuff -
but continue to do some of the hard things as well. You can't possibly do
everything so always look for the highest ROI.

It is Monday morning and you have just updated your action list. You have 30
items that you really need to get done today. Is this realistic? You can tell
yourself that you will really try hard today and get it all done but you know it
is impossible.

Make sure that the eight to ten things that you actually address are the most
critical. Everything else will have to wait or go to someone else. Remember,
when something should really get done and doesn't make the cut, you are creating
a project IOU for the item and your debt just went up. This might be a defect in
the code. It could be a design alternative to investigate or a communication to
be sent to upper management. There are many actions that must be taken and every
deferred action becomes a debt to the project.

Someday you must give an account. Try to defer the tasks that don't produce a
critical value for the project. Neglect the mindless formalities that are
imposed by every organization in favor of tasks that get you closer to business
success.


==== Work Left Undone

I once worked on a project where a massive amount of code had been written by a
brilliant individual in a top-of-mind orgy of complexity. There was a single
function that was 3000 lines long. I printed it out so that I could review and
understand the structure. The nesting of the indent levels was so great that the
code would wrap horizontally off the end of the line. It required multiple
lines of output to show one line of text. That day I learned what massive
technical debt looks like.

The tragedy of this situation was that the functionality of the code was indeed
brilliant - the business value of the system was very high. But the coding debt
was large enough to bring the net value of the system into question.

What is the debt? If debt occurs when you write the IOU, then its value can be
quantified. What will it take (in hours) to fix the problem? This  will let you
easily measure any type of debt in your system.

In the project I just referenced, I spent about 40 hours refactoring the massive
knot in the code. The system represented about 2,000 hours of development. We
<hr><p><a href="StartReading">Read More</a></p><hr>
