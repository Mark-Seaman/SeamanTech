** Code Leverage

{{ image_water }}


[quote, ~ Peter Drucker]
____

"There is nothing so useless as doing efficiently that which should not be done at all".
____


The actual activity of writing code is where implementing best practices across
an entire team can rapidly multiply your leverage on any project. By focusing on
immediate business goals and using standardized tools, your team can rapidly
turn out the highest quality software time after time. Now we'll dig into the
details of that endeavor.


*** Tasks within Code Construction

Earlier we discussed the different development tasks that must be balanced
throughout the project. These tasks make up the essential work of
implementation. Coding requires four different types of fundamental activities.
Each type of task is built on a unique frame of reference. As code is built
these viewpoints must be expressed and held in balance throughout the
development cycle.

* Test - verify functionality
* Fix - repair defects and errors
* Extend - new features
* Improve - structure and performance

[[dev_tasks]]
.Development Tasks Must be Balanced
image::../images/Dev_Tasks.png['Development Task Types']

If any one of these tasks is neglected you will build up technical debt. This
can have disastrous results on a project unless it is corrected. Each of these
types of work has some key best practices associated with it. Maximum leverage
is achieved by solving the key problems in each area. Be careful to budget your
time to service each of these area with an equal amount of effort.

Each of these core perspectives has its own form of technical debt which results
from neglecting the required work. Each task also has its own best practices
that prevents the accumulation of debt. This chapter will explore each task and
show you how to overcome the related challenges.


*** Test - Verify Functionality

The speed of development is directly related to the speed of your testing.
Anyone can create a large amount of code and fail to integrate it into the
overall project. Testing is central to the coding effort - without adequate
testing your team will spend a large percentage of their time trying to debug
mystery problems that come and go.

The subject of testing is so critical to development that I've dedicated the next
chapter to it. In this chapter we will focus on how testing affects the coding
process itself. We will focus on the integration of coding and testing and leave
the mechanics of testing for later.

Before a new feature is added you should think about how that feature will be
tested. Once a test has been constructed for a desired feature it is easy to
implement the feature properly. More importantly, it gives you confidence that
features that were previously working properly are still working and it will
save countless hours of debugging things that were accidentally broken.
Extensive debugging is a sign of poor test coverage.


**** Begin with Tests

Before you start working in any area of the code you need to think about how
this can be tested. How will you know three months from now that the feature
isn't broken?  Writing a test lets you know when the feature is complete and
that same test will prevent the feature from being broken without you knowing
about it immediately.

Write requirements as tests. Use the tests to specify what the product must
do. Be specific about the starting and ending assumptions - the test should
reflect what you assume to be true. If you write a line of product code then
it should be tested with a line of test code. Ultimately, you will create as
much test code as product code. This is one way to get quick feedback about
the quality of your coverage. If only 10% of your code is tests then you
aren't getting adequate coverage.

Defects discovered throughout development are another piece of feedback - it
is a clue that a required test is missing. Create a test for each defect that
you discover in your product, thereby filling the gap to prevent this defect
in the future. Prevent defects from becoming repeat offenders; recidivism is
another sign of poor test coverage.


**** Limit to One Line of Code

The best test is a simple one-line assertion. Verify all of the assumptions
that you believe should be true. If your assumption doesn't hold then learn
from it. A test should be simple to write and simple to correct. If you
believe that there should never be less than thirty customers in the database
or 100,000 files on the file system then express that as a single line of
