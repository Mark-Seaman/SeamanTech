* 10 Ways to Increase Leverage *                                       -*-muse-*-

---

Most companies waste a significant portion of their software development resources by not protecting and utilizing their key software assets. There are some simple techniques for leveraging your software investment.  They require discipline and focus, but are no difficult to do. 

Making change in your organization can be hard. But the benefits can be enormous for the success of your business.  By studying how to reuse software you can significantly lower your total development cost.  Software can last decades instead of a few short years.  Here are ten specific things you can do to extend the value of your software.

---

**1. Make reuse a fundamental element of your software planning**

Many organizations think about the lifespan of software as an afterthought. This seriously limits how reuse of your software.  It affects the tools that you select, how you organize the team, and how you architect the product.

Each project should begin with a concrete plan for how much and which parts of your software will be leveraged either to or from other projects.  This allows you to have a specific plan for how you will realize the desired level of reuse.

Without a plan you will assume a much higher leverage that you will actually ever achieve.  Most projects are a logical progression from a previous implementation.  If 90% of the product requirements remain the same then, everyone naturally assumes that you will only have to create 10% of the code.

Without an explicit leverage plan the result is more likely to be 60% or the cost of the previous project.  This would result in a cost five times larger than what was expected.

---

**2. Use a four-layer architecture: Foundation, Services, Application Services, Application **


Every project must address a wide variety of concerns.  The concerns range from how to host the application to the specific business rules that the software must enforce.  Each type of concern within the system has very different characteristics for reuse.  It is useful to think about the layers as being isolated from each other, so that you can define the appropriate levels of reuse.

The Foundation Layer defines how the application is deployed.  Service providers, operating systems, database strategies, and generalized platform tools should be reused on each project you do.  You must build deep expertise in these sets of tools.  Switching technologies introduces an enormous learning curve.

The Foundation Layer reuse is primarily knowledge of how to set up, configure, and utilize the tools. You should always use off-the-shelf tools.  Be sure and budget for the learning curve on any technologies that you are switching.   Learning requires ten times the effort of using a technology that you have used many times.

The Services Layer is the collection of general tools that you install and configure for your organization.  This covers things like web frameworks, asynchronous data communications, task processing, data transformation, graphics libraries, and toolkits.

Reuse in the Services Layer is about knowing how to use the tool properly for the task at hand.   Do not switch the technologies very often.  You should plan on using a common technology stack for ten projects before you replace it with something.  This lets you amortize the cost of learning.

The App Services Layer contains the generalized logic that your organization creates.  The Foundation and Services are technologies that you use but do not develop.  App Services covers all of the most reusable code that addresses the concerns of your domain.

The opportunity for reuse is centered around the App Services code.  Create a well encapsulated framework that embodies the most treasured assets for your organization.

Finally, the Application Layer is a customization of the specific business logic that is needed by a specific product version.  This should be around 10% of the code that you produce.  Measure the lines of code within the Application Services and the Application Layers.  Set specific goals for each project about the level of reuse you expect.  With no specific goal you will drift toward 40% reuse.

---

**3. Create an architectural model based on reusable components**


Build a design that lets you optimize your product leverage.  Start by defining the simplest design to meet the immediate need for the first product.  When implementing the second product look for similarities throughout the design.  Refactor these common elements into a framework that can be used by both of the products.  This is the start of your reusable architectural model.

With each new application that you develop, the reusable framework will gain new functionality.  As the projects roll by, your app framework will become both broader and deeper.  The architectural framework will eventually solve 90% of all of the business problems that you need for your next app.

In the end, new apps are created simply by adding a small amount of specific business logic.  This approach is very cost effective because it minimizes the new software that must be developed.

---

**4. Build your entire design around core interfaces**


Every design contains a small number of key interfaces.  These are the connections between the components.  Most of the design work should focus on the quality of these key interfaces.

For example, a persistence layer will save, recall, list, query, add, and delete object in the system.  Think about what you would like to do at this interface.  This about the control and data flow at this point.  How would you like to record or inject data here?

---

**5. Create a Domain Specific Language for your most important interfaces**

A DSL can be built to perform all of the desired operations for each type of data.  Design your language around the objects and operations in your system.  These can be represented as nouns and verbs respectively.

Consider a standard set of operations (eg. add, update, list, show, delete) for each datatype. The verbs in the system represent the operations that are performed. They are typically implemented as functions or method calls on objects.  All of the business logic in an application comes down to these interactions between nouns and verbs. 

Examples:
list customer
add order
build inventory
import doomsday_device
launch missiles
signal surrender

---

**6. Create standard protocols for interacting with components**

The more standards that you use, the more reusable your application will be.  Some interfaces will let you leverage open standards like HTTP, CSS, HTML, XML, LDAP, or OAuth.  Any time you select an open standard you increase the flexibility for leverage.

Sometimes you need to create your own protocols, file formats, and Domain Specific Languages.  In this case, look for opportunities to leverage within your own company or domain.  If you have to build something, try to build something that you can reuse in future apps.  This will let you amortize the development cost and improve interoperability.

---

**7. Build a reusable application for your specific domain**

Most organizations build a series of applications that are very similar to each other.  Capitalize on this similarity.   Identify the common elements and design patterns.

These can be built into a generic application, which can be quickly customized to address specific business requirement.  This most effect way to accomplish this is to have a generic app that can be cloned.  This allows you to start a fresh project by instantiating the general code and then customizing it.

---

**8. Encapsulate business rules with a standard way to apply them**

Business rules are often implemented with other type of code.  If different types of logic are combined together it seriously limits the reuse that is possible.  For example, if a list box can have a limit of ten choices then it is easy to put this logic right into the view code.

Strive to have a clear separation of concerns.   Each part of the software should only be concerned with one type of problem.  Imagine isolating parts of your program from each other:  queries, data combination, presentation, data models, persistence, etc..

Sometimes the application of rules can be encapsulated with an abstract interface.  This gives your application a plug-in architecture that isolates the producers and consumers from each other.  Wait until you have a specific need for this type of architecture before you invest in building it.

---

**9. Automate all core interactions with your application**

Once you have a domain language you can use it to perform automated operations.   Doing remote control of your application opens up some surprising opportunities for testing by stimulating the application with custom scenarios.

Two patterns are particularly useful.   Capture and Playback lets you record live data on an interface and then replay the same data at a different time.  The Stimulus/Response  pattern lets you inject instructions into an interface and then compare the output to an expected response.

---

**10. Use Diff Testing to accelerate your test creation and maintenance**

Imagine that every test case could be a simple function that returns a block of text.  Each answer for a test can be compared with an expected result.  It is easy to create a function that runs a test and shows a difference between the actual and expected output.

For each difference the developer can either fix the test (or product), or approve the actual result as the new "right answer".  This simple design can be used to create or fix tests in less than one minute.

Implementing a general test strategy that is built on Diff Testing can be highly effective.  It make testing easy and quick, which leads to constant refactoring.  Development that is supported by quick testing is one of the most important ways that you can take maximize Software Leverage.

---

http://Shrinking-World.org


