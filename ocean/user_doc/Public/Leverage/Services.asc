== Services Architecture




=== Services that Scale

Building web services is perhaps the most common software task today. This
produces some unique opportunities for reuse.  We can create parts of a solution
that are easily isolated from one another.  Each of these services can solve a
simple problem and may end up having a different life-cycle than the rest of the
services that we use.  This promotes reuse by letting us repurpose existing
solutions to solve new problems.

The rise of microservices has given us new design ideas.  We can now think 
about building and deploying systems that are much more focused on solving a
specific part of the overall product.  Then we can build more complex systems
by integrating them together to provide robust solutions for our customers.

Each of the services are built to address a specific concern.  By limiting the
functionality of each system we can build systems that are far easier to
construct and operate.  Control and data flow must be designed to meet the
business needs.  The services paradigm makes scaling far easier than it has 
ever been. 

As the number of users push the boundaries of the existing system new designs
are needed to address the increased demand.  The well-designed architecture
built around services allows portions of the system to be replaced to
accommodate the new demands without disrupting the entire system.  Therefore
our architecture directly sets the leverage potential of our web services.


==== Scaling your Architecture

Services are intended to work well for some number of users.  As demand increases
minor changes can be made to provide the required performance up to a certain
limit.  Eventually the demands of the new users can't be met by the current 
solution.  New bottlenecks emerge as the system grows. A system that works 
well for 100 concurrent users will not work for 1000, and a solution for 10,000
users will not scale to 100,000. 

Usage can be measured in requests per second that the system is intended to
respond to. Every order of magnitude in usage requires that some fundamental 
elements of the design be revisited.  Each of these orders in growth represents
a technical horizon, and typically has a corresponding business horizon for 
the company as well. What is your next horizon and how quickly do you need to
meet it?  Some business are under tremendous pressure to scale while others
are not.

This chapter lays out some principles and practices that will help you scale
your systems.  If scaling is not a major issue for you then you can skip forward
to learn about other operational issues.

To build services that scale you need to find and eliminate the bottlenecks that
are preventing your system from performing at the required level.  Once a key
choke point has been identified a new design must remove the bottleneck while
not disturbing anything else.


==== Design for Leverage

Reuse is an architectural concern.  A poor design is very difficult to change to
meet new requirements.  Modifying one part of the design forces an understanding
of the entire system and may break the software in unexpected ways. This is  a
design problem.  In order to scale your services you must start with a realistic
assessment of if your system can be scaled.  Is the design sound enough to let
you refactor portions safely? If not you are better off building a new system
that leverages the understanding while rewriting the current system.

The preferred option is to scale your existing system rather than replace it.
Scaling your current system means that you are working with legacy code.
Everything discussed in the chapter about Design Leverage applies here. 
Architectural and development requirements include:

* Complete battery of end-to-end tests with high test coverage
* Core skill at refactoring
* Version control of all app and configurations
* Skill at instrumenting and performance measurement
* Effective development process to deploy code safely
* Robust server strategy: dev, test, staging, production

If you are lacking any of these key ingredients then fill the gap before moving
on. Ignoring these issues can result in making serious mistakes that are 
difficult to recover from.  When you have what you need it is time to begin
the work of scaling to the next horizon.

The actual work of scaling starts with finding the next bottleneck that is 
holding you back.  Is your application compute bound or I/O bound, which servers
are backing up the requests, which queues are getting long, where is your 
maximum latency?  Use analytic tools to watch all of the servers and how they
perform.  Find the next hot spot.  This is your target for redesign.

Now, propose several different ways to solve the problem and select the simplest
first. Prototype the proposed solution and see if it scales to the demands of
the next generation.  If it does then simplify it further. Build bridges and
adapters to let you use all of the other parts of your system without
modification.  Once you are sure that this solution works then you can remove
the extra logic for the adapters to get to the final solution.


<hr><p><a href="StartReading">Read More</a></p><hr>
